#ifndef Custom_Lib_defined
      return 1;
}

// Writes the functions you need here

// Added this define to prevent multiple linking issue that might happen on complex shaders - i.e using tesselation 

#define Custom_Lib_defined 1


float4 ReturnUVAsColor(float2 inUV)
{
	
	return float4(inUV.x,inUV.y,0.0,1.0);
}

float2 ReturnUV_ForShaderToy(float2 inUV)
{
	
	return float2(inUV.x,1.0-inUV.y);
}


// inigo quilez - Shadertoy - https://www.shadertoy.com/view/3lsSzf


// Created by inigo quilez - iq/2019
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
//
//
// An animation test - a happy and blobby creature jumping and
// looking around. It gets off-model very often, but it looks
// good enough I think.
//
// Making of and related math/shader/art explanations (6 hours
// long): https://www.youtube.com/watch?v=Cfe5UQ-1L9Q
//
// Video capture: https://www.youtube.com/watch?v=s_UOFo2IULQ




//------------------------------------------------------------------

// HLSL fmod != GLSL mod
float mod(float x, float y)
{
  return x - y * floor(x/y);
}

// http://iquilezles.org/www/articles/smin/smin.htm
float smin( float a, float b, float k )
{
    float h = max(k-abs(a-b),0.0);
    return min(a, b) - h*h*0.25/k;
}

// http://iquilezles.org/www/articles/smin/smin.htm
float2 smin( float2 a, float2 b, float k )
{
    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );
    return lerp( b, a, h ) - k*h*(1.0-h);
}

// http://iquilezles.org/www/articles/smin/smin.htm
float smax( float a, float b, float k )
{
    float h = max(k-abs(a-b),0.0);
    return max(a, b) + h*h*0.25/k;
}

// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
float sdSphere( float3 p, float s )
{
    return length(p)-s;
}

// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
float sdEllipsoid( in float3 p, in float3 r ) // approximated
{
    float k0 = length(p/r);
    float k1 = length(p/(r*r));
    return k0*(k0-1.0)/k1;
}

float2 sdStick(float3 p, float3 a, float3 b, float r1, float r2) // approximated
{
    float3 pa = p-a, ba = b-a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return float2( length( pa - ba*h ) - lerp(r1,r2,h*h*(3.0-2.0*h)), h );
}

// http://iquilezles.org/www/articles/smin/smin.htm
float4 opU( float4 d1, float4 d2 )
{
	return (d1.x<d2.x) ? d1 : d2;
}

//------------------------------------------------------------------


//------------------------------------------------------------------

#define ZERO (min(0 /*iFrame*/,0)) // iFrame is current frame of the animation on Shadertoy

//------------------------------------------------------------------

float href = 0.f;
float hsha = 0.f;

float4 map( in float3 pos, float atime , float iTime)
{
    hsha = 1.0;
    
    float t1 = frac(atime);
    float t4 = abs(frac(atime*0.5)-0.5)/0.5;

    float p = 4.0*t1*(1.0-t1);
    float pp = 4.0*(1.0-2.0*t1); // derivative of p

    float3 cen = float3( 0.5*(-1.0 + 2.0*t4),
                     pow(p,2.0-p) + 0.1,
                     floor(atime) + pow(t1,0.7) -1.0 );

    // body
    float2 uu = normalize(float2( 1.0, -pp ));
    float2 vv = float2(-uu.y, uu.x);
    
    float sy = 0.5 + 0.5*p;
    float compress = 1.0-smoothstep(0.0,0.4,p);
    sy = sy*(1.0-compress) + compress;
    float sz = 1.0/sy;

    float3 q = pos - cen;
    float rot = -0.25*(-1.0 + 2.0*t4);
    float rc = cos(rot);
    float rs = sin(rot);
    q.xy = mul(float2x2(rc,rs,-rs,rc),q.xy);
    float3 r = q;
	href = q.y;
    q.yz = float2( dot(uu,q.yz), dot(vv,q.yz) );
    
    float4 res = float4( sdEllipsoid( q, float3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );

    if( res.x-1.0 < pos.y ) // bounding volume
	{
    float t2 = frac(atime+0.8);
    float p2 = 0.5-0.5*cos(6.2831*t2);
    r.z += 0.05-0.2*p2;
    r.y += 0.2*sy-0.2;
    float3 sq = float3( abs(r.x), r.yz );

	// head
    float3 h = r;
    float hr = sin(0.791*atime);
    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));
    h.xz = mul(float2x2(cos(hr),sin(hr),-sin(hr),cos(hr)),h.xz);
    float3 hq = float3( abs(h.x), h.yz );
   	float d  = sdEllipsoid( h-float3(0.0,0.20,0.02), float3(0.08,0.2,0.15) );
	float d2 = sdEllipsoid( h-float3(0.0,0.21,-0.1), float3(0.20,0.2,0.20) );
	d = smin( d, d2, 0.1 );
    res.x = smin( res.x, d, 0.1 );
    
    // belly wrinkles
    {
    float yy = r.y-0.02-2.5*r.x*r.x;
    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));
    }
        
    // arms
    {
    float2 arms = sdStick( sq, float3(0.18-0.06*hr*sign(r.x),0.2,-0.05), float3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );
    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );
    }
        
    // ears
    {
    float t3 = frac(atime+0.9);
    float p3 = 4.0*t3*(1.0-t3);
    float2 ear = sdStick( hq, float3(0.15,0.32,-0.05), float3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );
    res.xz = smin( res.xz, ear, 0.01 );
    }
    
    // mouth
    {
   	d = sdEllipsoid( h-float3(0.0,0.15+4.0*hq.x*hq.x,0.15), float3(0.1,0.04,0.2) );
    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);
    res.x = smax( res.x, -d, 0.03 );
    }

	// legs
    {
    float t6 = cos(6.2831*(atime*0.5+0.25));
    float ccc = cos(1.57*t6*sign(r.x));
    float sss = sin(1.57*t6*sign(r.x));
	float3 base = float3(0.12,-0.07,-0.1); base.y -= 0.1/sy;
    float2 legs = sdStick( sq, base, base + float3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );
    res.xz = smin( res.xz, legs, 0.07 );
    }
        
    // eye
    {
    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);
    float eyeball = sdSphere(hq-float3(0.08,0.27,0.06),0.065+0.02*blink);
    res.x = smin( res.x, eyeball, 0.03 );
    
    float3 cq = hq-float3(0.1,0.34,0.08);
    cq.xy = mul(float2x2(0.8,0.6,-0.6,0.8),cq.xy);
    d = sdEllipsoid( cq, float3(0.06,0.03,0.03) );
    res.x = smin( res.x, d, 0.03 );

    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-float2(0.095,0.285))*float2(1.0,1.1)));
    res = opU( res, float4(sdSphere(hq-float3(0.08,0.28,0.08),0.060),3.0,0.0,eo));
    res = opU( res, float4(sdSphere(hq-float3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));
    }
	}
    
    // ground
    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));
    float t5f = frac(atime+0.05);
    float t5i = floor(atime+0.05); 
    float bt4 = abs(frac(t5i*0.5)-0.5)/0.5;
    float2  bcen = float2( 0.5*(-1.0+2.0*bt4),t5i+pow(t5f,0.7)-1.0 );
    
    float k = length(pos.xz-bcen);
    float tt = t5f*15.0-6.2831 - k*3.0;
    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5f);
    float d = pos.y - fh;
    

    // bubbles
    {
    float3 vp = float3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);
    float2 id = float2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );
    float fid = id.x*11.1 + id.y*31.7;
    float fy = frac(fid*1.312+atime*0.1);
    float y = -1.0+4.0*fy;
    float3  rad = float3(0.7,1.0+0.5*sin(fid),0.7);
    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    
    float siz = 4.0*fy*(1.0-fy);
    float d2 = sdEllipsoid( vp-float3(0.5,y,0.0), siz*rad );
    
    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));
    d2 *= 0.6;
    d2 = min(d2,2.0);
    d = smin( d, d2, 0.32 );
    if( d<res.x ) { res = float4(d,1.0,0.0,1.0); hsha=sqrt(siz); }
    }

    // candy
    {
    float fs = 5.0;
    float3 qos = fs*float3(pos.x, pos.y-fh, pos.z );
    float2 id = float2( floor(qos.x+0.5), floor(qos.z+0.5) );
    float3 vp = float3( frac(qos.x+0.5)-0.5,qos.y,frac(qos.z+0.5)-0.5);
    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + float2(0.0,2.0) );
    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);
    float fid = id.x*0.143 + id.y*0.372;
    float ra = smoothstep(0.0,0.1,den*0.1+frac(fid)-0.95);
    d = sdSphere( vp, 0.35*ra )/fs;
    if( d<res.x ) res = float4(d,5.0,qos.y,1.0);
    }
    
    return res;
}

float4 castRay( in float3 ro, in float3 rd, float time , float iTime)
{
    float4 res = float4(-1.0,-1.0,0.0,1.0);

    float tmin = 0.5;
    float tmax = 20.0;
    
	#if 1
    // raytrace bounding plane
    float tp = (3.5-ro.y)/rd.y;
    if( tp>0.0 ) tmax = min( tmax, tp );
	#endif    
    
    float t = tmin;
    for( int i=0; i<256 && t<tmax; i++ )
    {
        float4 h = map( ro+rd*t, time ,iTime);
        if( abs(h.x)<(0.0005*t) )
        { 
            res = float4(t,h.yzw); 
            break;
        }
        t += h.x;
    }
    
    return res;
}

// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm
float calcSoftshadow( in float3 ro, in float3 rd, float time , float iTime)
{
    float res = 1.0;

    float tmax = 12.0;
    #if 1
    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane
    if( tp>0.0 ) tmax = min( tmax, tp );
	#endif    
    
    float t = 0.02;
    for( int i=0; i<50; i++ )
    {
		float h = map( ro + rd*t, time ,iTime).x;
        res = min( res, lerp(1.0,16.0*h/t, hsha) );
        t += clamp( h, 0.05, 0.40 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
float3 calcNormal( in float3 pos, float time , float iTime)
{
    
#if 0
    float2 e = float2(1.0,-1.0)*0.5773*0.001;
    return normalize( e.xyy*map( pos + e.xyy, time ,iTime).x + 
					  e.yyx*map( pos + e.yyx, time ,iTime).x + 
					  e.yxy*map( pos + e.yxy, time ,iTime).x + 
					  e.xxx*map( pos + e.xxx, time ,iTime).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    float3 n = float3(0.0,0.0,0.0);
    for( int i=ZERO; i<4; i++ )
    {
        float3 e = 0.5773*(2.0*float3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.001*e,time,iTime).x;
    }
    return normalize(n);
#endif    
}

float calcOcclusion( in float3 pos, in float3 nor, float time , float iTime)
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float h = 0.01 + 0.11*float(i)/4.0;
        float3 opos = pos + h*nor;
        float d = map( opos, time ,iTime).x;
        occ += (h-d)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );
}

float3 render( in float3 ro, in float3 rd, float time , float iTime)
{ 
    // sky dome
    float3 col = float3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;
    // sky clouds
    float2 uv = 1.5*rd.xz/rd.y;
    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mul(float2x2(0.8,0.6,-0.6,0.8),float2(2.1,2.1));
          cl += 0.5*(sin(uv.x)+sin(uv.y));
    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));
    // sky horizon
	col = lerp( col, float3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );    
    

    // scene geometry
    float4 res = castRay(ro,rd, time,iTime);
    if( res.y>-0.5 )
    {
        float t = res.x;
        float3 pos = ro + t*rd;
        float3 nor = calcNormal( pos, time,iTime );
        float3 ref = reflect( rd, nor );
        float focc = res.w;
        
        // material        
		col = float3(0.2,0.2,0.2);
        float ks = 1.0;

        if( res.y>4.5 )  // candy
        { 
             col = float3(0.14,0.048,0.0); 
             float2 id = floor(5.0*pos.xz+0.5);
		     col += 0.036*cos((id.x*11.1+id.y*37.341) + float3(0.0,1.0,2.0) );
             col = max(col,0.0);
             focc = clamp(4.0*res.z,0.0,1.0);
        }
        else if( res.y>3.5 ) // eyeball
        { 
            col = float3(0.0,0.0,0.0);
        } 
        else if( res.y>2.5 ) // iris
        { 
            col = float3(0.4,0.4,0.4);
        } 
        else if( res.y>1.5 ) // body
        { 
            col = lerp(float3(0.144,0.09,0.0036),float3(0.36,0.1,0.04),res.z*res.z);
            col = lerp(col,float3(0.14,0.09,0.06)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));
        }
		else // terrain
        {
            // base green            
            col = float3(0.05,0.09,0.02);
            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));
            col += f*float3(0.06,0.06,0.02);
            ks = 0.5 + pos.y*0.15;
            
			// footprints            
            float2 mp = float2(pos.x-0.5*(mod(floor(pos.z+0.5),2.0)*2.0-1.0), frac(pos.z+0.5)-0.5 );
            float mark = 1.0-smoothstep(0.1, 0.5, length(mp));
            mark *= smoothstep(0.0, 0.1, floor(time) - floor(pos.z+0.5) );
            col *= lerp( float3(1.0,1.0,1.0), float3(0.5,0.5,0.4), mark );
            ks *= 1.0-0.5*mark;
        }
        
        // lighting (sun, sky, bounce, back, sss)
        float occ = calcOcclusion( pos, nor, time,iTime )*focc;
        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);
        
        float3  sun_lig = normalize( float3(0.6, 0.35, 0.5) );
        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );
        float3  sun_hal = normalize( sun_lig-rd );
        float sun_sha = calcSoftshadow( pos, sun_lig, time,iTime );
		float sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));
		float sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));
        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));
        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);
        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(float3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );
        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);

		float3 lin = float3(0.0,0.0,0.0);
        lin += sun_dif*float3(8.10,6.00,4.20)*float3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);
        lin += sky_dif*float3(0.50,0.70,1.00)*occ;
        lin += bou_dif*float3(0.20,0.70,0.10)*occ;
        lin += bac_dif*float3(0.45,0.35,0.25)*occ;
        lin += sss_dif*float3(3.25,2.75,2.50)*occ;
		col = col*lin;
		col += sun_spe*float3(9.90,8.10,6.30)*sun_sha;
        col += sky_spe*float3(0.20,0.30,0.65)*occ*occ;
      	
        col = pow(col,float3(0.8,0.9,1.0) );
        
        // fog
        col = lerp( col, float3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );
    }

    return col;
}

float3x3 setCamera( in float3 ro, in float3 ta, float cr )
{
	float3 cw = normalize(ta-ro);
	float3 cp = float3(sin(cr), cos(cr),0.0);
	float3 cu = normalize( cross(cw,cp) );
	float3 cv =          ( cross(cu,cw) );
    return float3x3( cu, cv, cw );
}




float DummyReturnFunction() 
{

#endif